## 设计文档 ##

设计文档是CouchDB里的一种特殊类型的文档, 它包含了应用代码. 因为它运行在数据库之内, 所以其应用API是高度结构化的. 在前面的章节里, 我们已经看过了JavaScript视图以及其他的函数. 在本章里, 我们来看看函数API, 接着来探讨下设计文档中的函数和应用程序是如何相关联的.

### 文档建模 ###

在我们的经验里, 有两种文档. 第一种文档就是像那种用word保存下来的文档或者用户的个人信息. 要处理这种文档, 你想要尽可能的使它们规范化. 最基本的, 你会想要在一个请求里就能读取文档, 并得到一些有用的东西可以用来展现.

有一种技术可以用来创建"虚拟"文档, 它通过使用视图把数据收集组合到一起来实现. 利用此技术, 你可以把用户个人信息中的每个属性存储到每个不同的文档中, 但是我不会推荐这样做. 当视图是通过合并不同作者的工作而创建时, 虚拟文档很用; 比如, 我们的参考例子, 一个博客日志, 以及它的评论. Christopher Lenz写的[CouchDB Joins](http://www.cmlenz.net/archives/2007/10/couchdb-joins)这篇博客里, 涵盖了这方面更多的细节.

这种"虚拟文档"的概念把我们带到了另一种文档---事件日志. 当不信任用户输入或者需要做异步工作时, 在这些时候可以使用这种文档. 它以事件的形式记录用户动作, 所以在保存的时候只需要非常少的验证. 在载入文档进行进一步处理时, 你需要做一些关系数据库形式的约束检查.

你可以把文档看成是状态机, 带有用户输入和后台进程来管理文档状态. 你可以根据状态, 使用视图来找出相关的文档---改变它的状态则会在视图中移动它.

这种实现对于做日志来说同样有用--和batch=ok的参数相结合, CouchDB可以作为一个很好的日志存储器, 并且reduce视图对于找出像平均响应时间或者高活跃度用户之类的统计来说非常理想.

### 查询服务器 ###

CouchDB的默认查询服务器(执行设计文档函数的软件包)是用JavaScript写的, 但是存在几乎任何其他你可以想像到语言的视图服务器实现. 实现一种新语言的查询服务器只是f需要用简单几行程序处理几个JSON命令而已.

在这部分里, 我们会回顾已存在的功能, 像MapReduce视图, 更新验证函数, 展现和列表变换函数. 我们还会简要的描述在CouchDB路线图上将会有的功能, 比如复制过滤, 非JSON输入的更新处理器, 以及为了让应用URL看起来更加美观而重新实现的处理器. 因为CouchDB是一个开源项目, 我们不能保证某个计划中的特性到底会在什么时候实现, 但我们希望所有这些特性在你读到本书的时候都已经实现了. 在讲到那些还没有加入CouchDB代码库的特性时, 我们会讲清楚的.

在这一章节中, 我们会来看看设计文档, 以及它是如何嵌入CouchDB的架构来提供服务的. 在这里讲到的原则在扩展, 集成, 独立运行上都适用.

### 应用即文档 ###

CouchDB的设计是, 在应用和设计文档一一对应时, 工作的最好.

设计文档是指CouchDB中id以_design/开头的文档. 比如, 我们的示例blog应用, Sofa, 以id _design/sofa存储在设计文档中. 设计文档和其他CouchDB相似: 它们和其他文档一样可以被复制, 并且同样通过rev参数跟踪编辑冲突.

就像我们已经看到的那样, 设计文档是普通的JSON文档, 不同的是它们的文档id的前缀是_design/.

CouchDB会在这里寻找视图和其他应用函数. 我们应用的静态HTML页面作为设计文档的附件存储. 视图和验证函数, 不作为附件存储, 而是直接包含在设计文档的JSON体中.

![我们的设计文档的剖析](design/01.png)

图1: 我们的设计文档的剖析

CouchDB的MapReduce查询存储在views域中. 这是为什么Futon可以显示并且允许你编辑MapReduce查询的原理. 视图索引根据函数文本内容的指纹, 以每个设计文档为基本进行存储. 这意味着, 如果你编辑了设计文档的附件, 验证, 或者其他非视图的(或语言的)域, 视图索引不会重新生成. 然而, 如果你改变了一个map或者一个reduce函数, 视图索引会被删除, 且一个新的视图索引会根据新的视图函数建立.

CouchDB可以返回纯JSON以外的格式. 设计文档的show和list域包含函数用于把纯JSON转化成HTML, XML或者其他的Content-Types. 这使得CouchDB不用其他中间件就可以作为一个Atom feeds. show和list函数有点像传统web框架中的"actions", 会基于请求执行一些代码, 然后作出返回. 然而, 它们的不同之处是, show和list函数没有副作用. 这意味着, 它们主要被限制于处理GET请求, 但是同时也意味着它们可以被像Varnish这样的代理缓存.

因为应用逻辑被包含于一个单一的文档, 代码更新可以通过CouchDB的复制来完成. 这也打开了一个数据库托管多个应用的可能性. 一个报纸编辑需要的界面和一个读者想要大相径庭, 尽管背后的数据大多是相同的. 它们可以被托管在同一个数据库, 不同的设计文档上.

一个CouchDB数据库可以包含许多设计文档. 下面是一些示例设计文档id:

				_design/calendar
				_design/contacts
				_design/blog
				_design/admin

完整的CouchDB URL结构里, 你能够通过这样的URL来得到设计文档的JSON:

				http://localhost:5984/mydb/_design/calendar
				http://localhost:5984/mydb/_design/contacts
				http://localhost:5984/mydb/_design/blog
				http://localhost:5984/mydb/_design/admin

我们展示这个是为了让人们注意, 设计文档有一个特别的地方, 它们是唯一可以在URL里使用文本斜杠的文档. 我们这么做是因为没人喜欢在浏览器的地址栏里看到%2F这样的字符. 在其他文档里, 带有斜杠的文档id必须在URL被转义. 比如文档id movie/jaws会显示成这样的URL:http://localhost:5984/mydb/movies%2Fjaws.

我们在开发示例应用的第一个迭代里不会用到show和list, 因为通过JSON API来写Ajax查询可以更好的把CouchDB作为一个数据库来教学. 第一个迭代里我们使用的API和用来分析日志数据, 实现判断或者管理持久化查询的API是一样的.

在第二个迭代里, 我们会升级我们的示例blog, 让它可以在客户端JavaScript关闭的情况下工作. 而现在, 使用Ajax查询可以给我们更多的透明度来理解CouchDB的JSON/HTTP API是如何工作的. JSON是JavaScript的一个子集, 所以它和JavaScript一起用时遇到的阻力很小, 而浏览器的XMLHttpRequest(XHR)对象可以帮我们处理HTTP的细节.

CouchDB使用validate_doc_update函数来防止无效的或者未授权的文档更新. 我们在示例应用中使用它来保证blog post只能由登录用户管理. CouchDB的验证函数同样不会有任何副作用, 此外它不仅可以阻止终端用户的文档保存, 还可以阻止来自其他节点的复制文档. 我们会在本书的第三部分, "示例应用"里详细来讲验证函数.

Sofa所需要的原生的图片, JavaScript, CSS和HTML资源保存在_attachments域中, 有趣的是, 默认它只显示文件元信息, 而不是文件的全部内容. 所有的CouchDB文档都可以有附件, 不仅仅是设计文档, 所以应用程序资源管理可以变得极其灵活. 如果应用程序需要一组资源才能跑起来, 你应该把它们被附加到设计文档. 这意味着一个新用户可以轻松的在一个空数据库里初始化你的应用.

上面展示的(以及我们将要使用的)设计文档的另外一些域是CouchApp为了方便放上去的(关于CouchApp的更多信息, 请查看第10章, 独立运行的应用程序). signatures域让我们可以避免更新硬盘和数据库间没有变化的附件---它通过比较文件内容散列来做到这一点. lib域用来保存附加的JavaScript代码和JSON数据, 用以在部署时插入到view, show以及validation函数里.

### 一个基本的设计文档 ###

下个部分, 我们会进入到设计文档的高级技术, 但在此之前, 让我们先来看一个最基本的设计文档. 所有我们要做的就是定义一个视图, 但是它应该已经足够向你展示, 设计文档是如何在更庞大的系统里工作的了.

首先, 用你的编辑器把下面的文本(或者类似的)加到一个叫做mydesign.json的文本文件里

				{
					"_id" : "_design/example",
					"views" : {
						"foo" : {
							"map" : "function(doc){ emit(doc._id, doc._rev)}"
						}
					}
				}

现在, 使用curl把这个文件PUT到CouchDB(我们会先创建一个数据库):

				curl -X PUT http://127.0.0.1:5984/basic
				curl -X PUT http://127.0.0.1:5984/basic/_design/example -d @mydesign.json

从第二个请求里, 你会看到类似的响应:

				{"ok":true,"id":"_design/example","rev":"1-230141dfa7e07c3dbfef0789bf11773a"}

现在, 我们可以查询我们定义的视图了, 在此之前, 应该加一些文档到数据库里, 这样我们才会有东西来查询. 执行下面的命令几次会加入一些空文档.

				curl -X POST http://127.0.0.1:5984/basic -d '{}'

现在, 再来查询视图:

				curl http://127.0.0.1:5984/basic/_design/example/_view/foo

这应该会给你一个数据库时所有文档的列表(除了设计文档). 你已经创建和使用了你的第一个设计文档!

### 展望未来 ###

还有其他的一些设计文档函数会在本书的进行过程中被介绍, 包括我们在这里没有深入介绍的_update和_filter. Filter函数会在第20章, "变更通知"里介绍. 想像一下, 当特定事件发生时, 一个web service会自动POST一个XML到一个你指定的URL. Paypal的实时支付通知就是其中的一种. 使用_update处理器, 你可以在CouchDB里直接POST这些并且它可以把XML解析成JSON文档并保存它. CSV, 多表单以及其他格式也一样.

大体上, 我们正在做就像是一个应用服务器, 但在一个关键点上不一样: 不是让开发者做任何他们想要做的(遍历文档id的列表, 然后做查询, 在其他查询的结果上再做查询, 等等), 我们会定义好那些"安全"的转换, 像view, show, list和update函数. 这里所说的安全意思是, 它们有已知的很好的性能, 并且能高效的嵌入到CouchDB的架构里.

这里的目标是提供一种途径可以构建一个独立的应用, 它可以很容易的被搜索引擎索引并且让用户使用. 因此, 放入了古老的纯HTML文本. 你可以放心的让JavaScript执行. 拥有HTML资源意味着, CouchDB适合于公共的网络应用.

只需要一个URL重写处理器和一个数据库事件处理器, 就可以很漂亮的描绘出一个应用了. 重写处理器可以让你的应用使用自己的URL, 使其可以更容易的整合到现有的系统中. 事件处理器可以让你在数据库改变时执行异步处理. 比如, 一个文档更新可以触发一个工作流, 多文档验证或者消息队列.

