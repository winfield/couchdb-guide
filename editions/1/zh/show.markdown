## 显示函数 ##

CouchDB的JOSN文档在大多数环境中都能被很好的编程处理. 几乎所有的语言都有HTTP和JSON库, 虽然可能性非常小, 但如果你所使用的语言不包含这些库, 自己写一个也相当的简单. 然而, 有一个很重要的使用场景, JSON文档没有考虑到: 构建古老的纯文本HTML网页. 浏览器很强大, 可以只使用CouchDB的JSON和HTTP API就能构建Ajax应用, 这非常激动人心, 但是这种实现方法对大多数面向大众开放的网站是不合适的.

HTML是web的通用语言, 是有其原因的. 通过把JSON文档展现成HTML页面, 我们使其可以让更广泛的用户使用. 如果使用纯Ajax的实现方法, 来我们Blog的那些有视力障碍的访问者就有可能看不到任何有用的内容了, 因为主流的屏幕阅读浏览器很难做到可以理解由JavaScript动态生成的内容的程度. 另一个作者关心的重要问题是, 他们写的东西要可以被搜索引擎索引. 如果读者不能通过搜索引擎找到, 那维护一个高质量的博客就变得不那么有趣了. 大多数的搜索引擎不会执行其找到的页面里的JavaScript, 所以对它们来说, 一个Ajax的博客看起来就像是没有内容的. 我们还不应该忘记, HTML作为一种存档格式在很长一段时间内, 要比我们前几章使用的平台特定的JavaScript和JSON实现更加友好. 还有, 使用纯文本HTML, 我们可以让我们的网站更整洁, 因为浏览器可以用更少的服务器通信来展现有意义的内容. 这些就是为什么使用HTML来提供网站内容更有道理的几个原因.

传统的方法来从数据库记录来展现HTML是通过中间层应用服务器, 像Ruby on Rails或者Django, 它们会把根据用户请求找出合适的记录, 然后根据这些记录执行模版函数, 最后把HTML结果返回给访问者的浏览器. 这些基本的流程在CouchDB作为数据库时没有什么变化; 对于一个应用服务器来说, 处理JSON视图和文档相当的直观. Rails或者Django(或者其他你选择的框架)不使用浏览器端JavaScript从CouchDB里载入JSON然后生成动态页面, 而是通过发出相同的HTTP请求到CouchDB, 使用返回的结果生成HTML, 然后再返回给浏览器. 在本书里, 我们不讨论这种实现, 因为它特定于不同的语言和框架. 讨论不同的实现会占比你想要读到的东西更多的篇幅.

CouchDB包含了一个应用中间件可以做的大多数的功能, 而不需要额外的软件辅助. 这种实现方式的吸引人之处在于, CouchDB本身就能支撑整个应用, 而不需要依赖于复杂的环境, 比如一个需要例行维护的Web服务器. 因为CouchDB被设计成能运行于客户端电脑, 在那里环境因素是不由应用开发者控制的, 所以拥有内建的模版能力极大的扩大了应用的潜在用户. 如果你的应用可以运行在一个标准的CouchDB实例上, 那就实现了部署的简易性和灵活性.

### 显示函数API ###

显示函数, 拥有一系列API用来保证其可缓存能力和操作的无副作用. 这和其他的应用服务器完全不同, 那些应用服务器给了程序员对任何请求做任何操作的自由. 让我们来看看一些显示函数的例子.

最基本的显示函数看起来就像下面这个样子:

				function(doc, req) {
					return '<h1>' + doc.title + '</h1>';
				}

如果一个文档有一个内容为"Hello World"的title域, 当这个函数执行时, 它会发送一个默认Content-Type为text/html, 编码为UTF-8, body为<h1>Hello World</h1>的HTTP响应.

显示函数request/response循环的简单性让它很难被过度使用. 我们最经常听到的问题是, "怎么样才能载入另一个文档, 这样我就可以同时生成它的内容?" 简单的回答是不行. 更详细的答案是, 对于一些应用来说, 你可能会要用列表函数生成视图结果为HTML, 这让你可以在函数的输入中加入多于一个的文档.

即使在使用一些更高级的特性时, 函数接受一个文档和一个请求参数, 返回一个响应, 没有副作用和另外的输入选项这些基本总是不会改变. 下面是一个复杂的显示函数, 演示了设置自定义HTTP头的能力:

				function(doc, req) {
					return {
						body : '<foo>' + doc.title + '</foo>',
						headers : {
							"Content-Type" : "application/xml",
							"X-My-Own-Header": "you can set your own headers"
						}
					}
				}

如果在前面那个的文档上执行这个函数, 返回结果会的Content-Type会是application/xml, body会是<foo>Hello World</foo>. 从这里你应该可以看出来了, 使用显示函数怎么样从任何文档, 生成你需要的输出.

显示函数主要用于输出HTML页面, CSV文件, 或者特定界面需要的XML. CouchDB的测试套件甚至演示了如何使用显示函数来生成一个PNG图片. 要返回二进制数据, 有一个选项可以返回Base64编码的字符串, 像这样:

				function(doc, req) {
					return {
						base64 :
							["iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAsV",
								"BMVEUAAAD////////////////////////5ur3rEBn////////////////wDBL/",
								"AADuBAe9EB3IEBz/7+//X1/qBQn2AgP/f3/ilpzsDxfpChDtDhXeCA76AQH/v7",
								"/84eLyWV/uc3bJPEf/Dw/uw8bRWmP1h4zxSlD6YGHuQ0f6g4XyQkXvCA36MDH6",
								"wMH/z8/yAwX64ODeh47BHiv/Ly/20dLQLTj98PDXWmP/Pz//39/wGyJ7Iy9JAA",
								"AADHRSTlMAbw8vf08/bz+Pv19jK/W3AAAAg0lEQVR4Xp3LRQ4DQRBD0QqTm4Y5",
								"zMxw/4OleiJlHeUtv2X6RbNO1Uqj9g0RMCuQO0vBIg4vMFeOpCWIWmDOw82fZx",
								"vaND1c8OG4vrdOqD8YwgpDYDxRgkSm5rwu0nQVBJuMg++pLXZyr5jnc1BaH4GT",
								"LvEliY253nA3pVhQqdPt0f/erJkMGMB8xucAAAAASUVORK5CYII="].join(''),
						headers : {
							"Content-Type" : "image/png"
						}
					};
				}

这个函数输出一个16x16像素的CouchDB logo. 从文档内容生成图片必要的JavaScript代码会比较复杂, 但是可以发送Base64编码的二进制数据意味着, 使用其他语言比如C或者PHP写的查询服务器有能力输出任何的数据类型.

### 没有副作用 ###

我们前面提到显示函数的一个关键约束是它们是没有副作用的. 这意味着你不能使用它们来更新文档, 杀掉后台进程, 或者触发其他函数. 从一个更高的层次来看, 这是一件好事情, 因为这样允许CouchDB提供标准的web框架所没有的性能和可靠性保证. 因为一个显示函数以相同的输入总是会输出相同的结果, 并且不能改变其运行环境中的任何东西, 所以输出就可以被缓存并且更好的重用. 在一个拥有适当缓存的高可用性部署中, 这意味着, 对于一个特定的文档, 一个显示函数只会被调用一次, 并且在接下来的请求里CouchDB服务器不必再被连接.

没有副作用对于那些习惯于有多种实现方案的应用服务器的开发者来说会有一点不知所措. 保证响应GET请求的方法没有副作用以及可缓存被认为是一种最佳实践, 但我们很少实现这种要求. CouchDB换了一个不同的角度: 因为它是一个数据库, 我们认为符合最佳实践(并且保证开发者不会写出对数据库服务器有损害的函数)比提供绝对的灵活性更加重要. 一旦你习惯于这些约束条件, 它们就变得很有道理了.(它们被认为是是佳实践是有原因的.)

### 设计文档 ###

在深入显示函数本身前, 我们先快速的来看看它们被是如何被存储在设计文档里的. CouchDB在设计文档的最上层的叫shows的域里查找显示函数, 域shows和views, lists以及filters是平行的. 下面的示例设计文档定义了两个显示函数:

				{
					"_id" : "_design/show-function-examples",
					"shows" : {
						"summary" : "function(doc, req){ ... }",
						"detail" : "function(doc, req){ ... }"
					}
				}

这里除了设计文档可以定义多个显示函数以外没什么其他的可以关注的了. 现在让我们来看看, 这些函数是如何运行的.

### 查询显示函数 ###

我们已经描述过了显示函数的API, 但是还没有看过这些函数是如何运行的.

显示函数存储于设计文档, 因此想要执行它, 我们把函数的名字附加到设计文档本身, 然后再加上我们想要从其生成的文档:

				GET /mydb/_design/mydesign/_show/myshow/72d43a93eb74b5f2

显示函数(以及其他的比如列表函数等)可以通过设计文档路径作为资源取到, 所有由一个特定设计文档提供的资源都可以在一个共同的根路径下找到, 这让自定义的应用代理变得更为简单. 我们会在本书的第三部分, "示例应用"里看到这样的一个例子.

如果一个ID为72d43a93eb74b5f2的文档不存在, 对于这个文档的请求会返回一个HTTP 500内部服务器错误. 这似乎有点不大友好; 为什么会发生这种情况? 如果我们查询的显示函数的文档ID没有指向一个存在的文档, 则函数里的doc参数就是null. 然后当显示函数试图去读取它时, JavaScript解析器并不喜欢这个样子. 所以它抛出异常来了. 要自定义的处理这些异常, 或者处理不存在的文档(比如, 一个wiki可以显示一个"创建一个页面"的页面), 你可以把函数包含在 if(doc !== null) { ... }里.

不过, 显示函数也可以不带文档ID来执行, 像这样子:

				GET /mydb/_design/mydesign/_show/myshow
	
在这种情况下, 函数的doc参数的值是null. 这种选项在显示函数不需要文档就能运行的时候会有用. 比如, 本书第三部分, "示例应用"章的示例应用里, 我们使用相同的显示函数来同时提供编辑现存日志和新建日志功能, 前者带文档ID执行, 后者不带. 另一种实现方法是维护另一个资源(比如一个静态的HTML附件)来提供同样的功能. 作为程序员, 我们会尽量的不去重复我们自己, 这促使我们给了显示函数可以不带文档ID执行的能力.

#### 设计文档资源 ####

除了可以执行显示函数, 其他资源也可以通过设计文档的路径得到. 设计文档的这种特性组合意味着应用在部署时, 通过一个简单的代理来重写路径, 可以不把整个CouchDB API暴露给访问者. 这里我们就不再深入了, 但最终用户在执行前面的查询时看到的路径就会像下面这个样子:  

				GET /_show/myshow/72d43a93eb74b5f2

在底层, 一个HTTP代理可以重写数据库和设计文档所在的路径(在这个例子里, /mydb/_design/mydesign), 这样CouchDB就能看到一个标准的查询. 有了这样一个系统, 最终用户就可以通过设计文档中定义的函数来访问应用, 这样开发者就能增加约束并防止对原始JSON文档和视图数据的访问. 虽然不能提供100%的安全性, 使用自定义的重写规则, 来控制最终用户对CouchDB应用的访问是一种高效的手段. 这个技术在本书写作的时候已经被运用于多个网站的生产环境了.

#### 查询参数 ####

请求对象(其包含了经过解析的查询参数)对于显示函数也是可见的. 作为例子, 下面的显示函数根据不同的URL查询参数会返回不同的数据.

				function(req, doc) {
					return "<p>Aye aye, " + req.parrot + "!</p>";
				}

带查询参数来请求这个函数会使得查询参数出现在最后的输出中:

				GET /mydb/_design/mydesign/_show/myshow?parrot=Captain

这个例子里, 我们会看到输出: <p>Aye aye, Captain!</p>

允许在函数里读取URL参数不会影响缓存能力, 因为不同的结果只会出现在不同的URL里. 然而, 过度使用这一特性会降低你的缓存效率. 类似的查询参数在转换显示函数的输出格式时最有用. 建议你不要在返回里带有用户自定义数据(比如发出请求的用户的昵称)里时使用这一特性, 因为那意味着每个用户的数据必须被单独缓存.

#### Accept头 ####

HTTP定义的一部分允许客户端提示服务器自己能够接受什么类型的数据. 目前, CouchDB 0.10.0内置的JavaScript查询服务器包含了辅助方法来设置Accept头. 然而, 浏览器对于Accept头的支持非常弱, 这促使像Ruby on Rails这样的框架去掉了对其的支持. CouchDB可以支持也可以不支持, 但不管如何还是不建议在通过浏览器访问的应用里依赖于Accept头.

有一组现成的Accept头辅助方法可以让你在查询参数里指定格式. 比如:

				GET /db/_design/app/_show/post
				Accept: application/xml

对浏览器而言, 这和带有与请求格式不相符的Accept头的是等同的. 这是因为浏览器对于feed URL的Accept头并不敏感. 

				GET /db/_design/app/_show/post?format=xml
				Accept: x-foo/whatever

请求函数允许开发者根据客户端请求来转换不同的Content-Type返回. 接下来会有一个例子, 其中加入了返回HTML, XML, 或者任何开发者需要的类型的功能.

CouchDB的main.js库提供了("format", render_function)函数, 这使得开发者可以更加方便的在一个函数里多个MIME类型的客户端请求.

这个函数也展示了如何使用registerType(name, mime_types)函数, 它可以添加用于respondWith函数的新类型. 其结果就是通过提供一个可以不同类型请求的接口, 实现了无限的灵活性. main.js使用了JavaScript实现的Mimeparse库, 它是一个提供类似服务的开源实现.

### Etags ###

我们在前面提到了, 显示函数没有副作用并且是可以被缓存的. 但是我们还没有讨论其实现原理. Etags是用来指示一个HTTP返回的缓存版本是否还存在的标准HTTP机制. 从本质上讲, 当客户端发出对一个资源的第一次请求时, 返回里会带有一个Etag, 这是一个唯一于被请求资源版本的不可见字符串. 当客户端第二次对同一个资源作出请求时, 它会把最初得到的Etag带在请求里发送出去. 如果服务器最后决定这个Etag仍然和这一资源匹配, 就可以避免发送一个完全的返回, 而是可以返回一个消息, 就像是在说:"你已经拥有这个资源的最新版本啦."

如果实现合理, Etag的使用可以极大的减轻服务器负载. CouchDB提供了一个Etag头, 所以通过使用像Squid这样的HTTP代理缓存, 将能持久的减轻CouchDB的负载.

### 函数与模版 ###

CouchDB的处理程序只会寻找放在show下面的函数, 但是我们想要把模版HTML从文档内容处理逻辑中独立出来. Couchapp脚本可以使用!code和!json处理函数来帮助我们完成这个任务.

让我们来看看Sofa实现的显示函数逻辑. 下面就是Sofa的编辑页面显示函数:

				function(doc, req) {
					// !json templates.edit
					// !json blog
					// !code vendor/couchapp/path.js
					// !code vendor/couchapp/template.js

					// we only show html
					return template(templates.edit, {
						doc : doc,
						docid : toJSON((doc && doc._id) || null),
						blog : blog,
						assets : assetPath(),
						index : listPath('index','recent-posts',{descending:true,limit:8})
					});
				}

这个函数看起来应该很直观. 首先, 我们定义了函数头, 也叫签名, 它告诉我们我们在处理的函数要接受两个参数: doc和req

接下来的四行是注释, 这是对于JavaScript来说的. 但是这些是些特殊的文档. CouchApp上传脚本知道如何在显示函数的最上面读取这些特殊的注释. 它们包含了宏; 一个宏由一个bang(!)和一个名字开始. 目前而言, CouchApp支持两种宏: !json和!code.

#### !json宏 ####

!json宏接受一个参数: 用点(.)形式表示的CouchApp目录结构里的一个文件. 不是使用斜杠(/)或者反斜杠(/), 而要使用点(.). !json宏然后就会读取文件的内容并把它们放入一个变量里, 这个变量的名字和文件的用点表示的路径相同.

举了例子, 如果你使用这样的宏:

				// !json template.edit

CouchDB会读取文件template/edit.*, 并把它的内容放入一个变量:

				var template.edit = "contents of edit.*"

指定路径时, 忽略了文件的扩展名. 这样你就能读取.json, .js, 或者.html文件, 或者任何其他文件到函数的变量里. 因为宏能符合任何扩展名, 所以你不能有两个拥有相同名字但不同扩展名的文件

另外, 你可以指定一个目录, CouchApp会载入这个目录及其子目录的所有文件. 就像这样:

				// !json template

这会创建:

				var template.edit = "contents of edit.*"
				var template.post = "contents of post.*"

注意, 宏还会创建顶层的template变量. 我们为了简略为省略它. !json宏只会生成可用的JavaScript.

#### !code宏 ####

!code宏和!json宏类似, 但是它有一个稍微不同的目的. 不是把一个或多个文件的内容以变量的形式提供给函数, 而是会用参数里指定的文件内容替换掉自已这个宏.

这对于在CouchDB函数(map/reduce/show/list/validate)里共享库函数很有用, 这样就不用在多个地方维护它们的源代码.

我们的例子:

				// !code vendor/couchapp/path.js

如果你看下CouchApp的源代码, 会找到一个文件: vendor/couchapp/path.js, 它包含了一堆和请求URL路径相关的有用函数. 在刚刚展示的例子里, CouchApp会把这一行替代成path.js的内容, 让其中的函数在show函数里可用.

!code宏一次只能载入一个文件.

### 学习如何进行显示 ###

在我们继续深入完整的生成日志的永久链接页面代码之前, 让我们先来看看几个"Hello World"的例子. 第一个显示函数只是一个带有最简单返回值的函数. 看图1, "函数的最基本形式"

![函数的最基本形式](show/01.png)

图1. 函数的最基本形式

显示函数是一个JavaScript函数, 它把文档和HTTP请求的一些细节转换为一个HTTP返回. 典型的, 比如会被使用于创建HTML, 但是它也能返回Atom feeds, 图片, 或者甚至是过滤后的JSON. 文档参数和在map函数里传入的文档参数是一样的.

### 使用模版 ###

显示函数开发中唯一令人不爽的是, 除非使用大量的字符串操作以及一些其他的不愉快方法, 就没法生成HTML, 而真那么做肯定会毁了你的眼睛的. 大多数编程环境通过使用模版来解决这个问题; 比如使用类似HTML的文档, 但其中包含有占位符, 其内容可以被动态填冲.

动态的组合模版字符串和数据在JavaScript中是一个已解决的问题. 然而, 它还没有流行起来, 有一部分原因是因为JavaScript对多行的"heredoc"字符串支持得不好. 不管怎么样, 一旦你做过转义引用以及删除空行之类的事就会知道, 编辑嵌入JavaScript代码中的HTML模版是一件多么蛋疼的事了. 我们最好还是把模版放在单独的文件里, 这样我们就可以避免所有的转义工作, 并且它们也可以被编辑器语法高亮.

CouchApp脚本拥有几个辅助方法可以让在设计文档使用模版和库代码少一些痛苦. 在图2, "博客日志模版"所示的函数中, 我们使用它们来加载一个博客日志模版, 以及用来生成这个模版的JavaScript函数.

![博客日志模版](show/02.png)

图2. 博客日志模版 

你可以看到, 我们利用了这个机会来把日志中的JavaScript标签去掉了. 那个正则表达式并不安全, 而一个博客应该只能由他的所有者有权写作. 所以我们也许应该去掉正则表达式, 简化函数来避免文档的转换, 不再把文档直接传入模版. 或者我们应该从其他语言里借鉴一个好用的处理方法, 然后提供到模版库中.

(译注: 图2与上下文似乎不符)

### 写模版 ###

使用模版, 而不是把所有显示代码放到一个文件里, 这使得编辑轻松了不少. 模版被存储在其自己的文件里, 所以你不用担心JavaScript或者JSON编码类型, 并且你的编辑器也可以高亮模版中的HTML语法. CouchDB的JavaScript查询服务器包含了JavaScript的E4X扩展, 这对于XML模版的解析有帮助但对于HTML却不是那么的友好. 我们会在第14章, 显示博客文章列表里来探索E4X模版, 那里我们会讲到视图的形式, 它使得提供一个视图结果的Atom feed可以变得简单且高效.

当我们说看这个HTML页面要比试图理解一个纯粹的JavaScript文件时要轻松的多时, 请相信我们. 我们在示例博客里使用的模版库是由John Resig写的, 选择它是因为其简单性. 它可以被轻易的替换为其他许多选择, 比如Django模版语言的JavaScript实现.

在这里, 我们也正好可以指出CouchDB的架构设计, 使得其可以简单的换成其他语言来作为查询服务器. 有了用Lisp, Python, 或者Ruby(或者其他任何支持JSON和stdio的语言), 你就有了更广泛的模版语言选择. 然而, CouchDB开发组组还是推荐使用JavaScript, 因为它提供了最高级别的支持和可操作性, 虽然其他的选择依然存在.

