## 显示博客日志列表 ##

最近的几个章节讨论了如何把数据从CouchDB里取出来. 你学到了如何建模数据到文档, 然后通过HTTP API把它取出来. 在本章节中, 我们会来看看实现Sofa首页的视图, 以及根据客户端请求生成这些HTML或者XML的list函数.

我们已经成功的创建了一个博客日志并用它生成了HTML, 我们将会创建一个首页, 让访问者在他们找到你的博客时能看到. 这个页面会有10个带有标题和简短摘要的最近日志的列表显示. 第一步是要写一个MapReduce查询来构建CouchDB查询博客日志的索引. 

在第6, Finding Your Data with Views里, 我们注意到reduce对于许多普通的查询来说并不需要. 对于首页来说, 我们只关心按照日期排序的日志, 所以我们不需要使用reduce函数, 单独的map函数就足够找出按日期排序的日志了.

### 最近博客日志的map函数 ###

现在你已经准备好可以写一个创建所有博客日志列表的map函数了. 这个视图的目的很简单: 根据日期来排序博客日志.

下面是视图函数的源代码. 我们会在重要的地方讲解一下.

				function(doc) {
					if (doc.type == "post") {

我们要做的第一件事情是保证我们在处理的文档是一个日志. 我们不想要评论或者其他任何不是日志的出现在首页上. 表达式doc.type == "post"在文档是日志时为true, 其他的则为false. 在第7章, 验证函数里, 我们了解了验证函数我了我们关于日志的一定的保障, 让我们能舒服的把内容放到博客的首页上去.

				  var summary = (doc.html.replace(/<(.|\n)*?>/g, '').substring(0,350) + '...');

这一行代码简短了日志的HTML(它是在保存前由Markdown生成的), 并把大多数的标签和图片去除掉了, 这样对于显示一个首页就足够简洁了.

接下来的这部分是视图最重要的部分. 我们生成每个文档的key(doc.created_at)和value. key用于排序, 这样我们就能高效的根据一个特定的日期范围找出所有的日志.

						emit(doc.created_at, {
							html : doc.html,
							summary : summary,
							title : doc.title,
							author : doc.author
						});

我们生成的value是一个JavaScript对象, 它从文档里复制了一些域(但不是所有的域), 以及我们刚刚生成的summary字符串. 避免生成整个文档总是一个更合理的方法. 作为一个一般法则, 你会想要保持视图尽可能的简洁. 只生成你将在应用里使用的数据. 在这个例子里我们生成了summary(用于首页), HTML(用于Atom feed), 日志标题, 和日志作者.

					}
				};

现在你应该已经能看懂前面那个map函数的定义了. emit()调用在视图结果集里为每个日志文档创建一条记录. 我们把这个视图叫recent-posts.我们的设计文档现在看起来应该是这个样子:

				{
					"_design/sofa",
					"views": {
						"recent-posts": {
							"map": "function(doc) { if (doc.type == "post") { ... code to emit posts ... }"
						}
					}
					"_attachments": {
						...
					}
				}

CouchApp会帮我们管理零碎的文件, 并把它们放入JSON设计文档里, 这样我们就能在像views/recent-posts/map.js这样的文件里编辑我们的视图了. 一旦map函数被存储入设计文档, 我们的视图就可以查询到最近的10个日志了. 再次地, 这看起来和显示一个单一的日志非常类似. 唯一真正不同的地方是我们得到的是一个JSON对象的数组, 而不是一个单一的JSON对象.

GET请求的URI是:

				/blog/_design/sofa/_view/recent-posts

一个在/database/_design/designdocname定义的视图可以在/database/_design/designdocname/_view/viewname里被调用.

你可以传入一个HTTP查询参数来自定义查询. 在这个例子里, 我们传入的是:

				descending: true, limit: 5
	
这个参数先取出最新的日志然后再找出最前面的5个.

最后的请求URL是:

				/blog/_design/sofa/_view/recent-posts?descending=true&limit=5

### 使用List函数把视图转化成HTML ###

在第5章, 设计文档中, 我们提到了_list函数. 在我们的举例应用里, 我们会使用一个JavaScript写的list函数来把最近日志的视图转化为XML和HTML格式. CouchDB的JavaScript视图服务器也搭载了返回合适的HTTP content negotiation和Accept头的能力.

_list API的本质就是一个函数, 它每次填充一行并一次返回一块数据 **

#### Sofa的List函数 ####

让我们来看看Sofa的list函数. 这是一个相当长的函数, 并且介绍了一些新的概念, 所以我们会放慢速度, 保证讲清楚一切你关心的东西.

				function(head, req) {
					// !json templates.index
					// !json blog
					// !code vendor/couchapp/path.js
					// !code vendor/couchapp/date.js
					// !code vendor/couchapp/template.js
					// !code lib/atom.js

函数的最上面声明了参数head和req. 我们的函数不使用head, 只使用了req, req包含了关于请求的信息, 像客户端发来的头和查询字符串. 函数的第一行是CouchApp宏, 它把其他地方的代码和数据导入设计文档. 这些宏让我们可以从其他地方导入短小的, 可读的函数到设计文档, 我们将在第11章, 管理设计文档里详细的讲解它们. 我们的list函数使用了CouchApp的JavaScript辅助方法来产生URL(path.js), 处理日期对象(date.js), 以及我们用来生成HTML的模版函数.

				  var indexPath = listPath('index','recent-posts',{descending:true, limit:5});
				  var feedPath = listPath('index','recent-posts',{descending:true, limit:5, format:"atom"});

接下来的两行生成了首页的URL, 以及它的XML Atom feed版本. listPath函数是在path.js里定义的, —the upshot is that it knows how to link to lists generated by the same design document it is run from.

接下来的部分负责生成博客的HTML输出. 关于这里我们使用的API, 参考第8章, Show函数. 简单的说, 客户端可以在HTTP Accept头里, 或者用查询参数里描述它们喜欢的格式. 在服务器端, 我们声明了我们提供的格式, 并且赋予每种格式一个优先级. 如果客户端接受多个格式, 第一个声明的格式会被返回. 浏览器能接受一大堆格式是很正常的, 所以注意把HTML放在列表的最上面, 否则在你想要浏览器接受HTML时结果却可能会是其他的格式.

				provides("html", function() {

provides函数接受两个参数: 格式的名称(根据默认的MIME types列表一一对应)和一个生成该种格式的函数. 注意, 在我们使用provides时, 所有的send和getRow调用都必须是在render函数里. 好了, 现在让我们来看看到底是如何生成HTML的.

						send(template(templates.index.head, {
							title : blog.title,
							feedPath : feedPath,
							newPostPath : showPath("edit"),
							index : indexPath,
							assets : assetPath()
						}));

我们首先看到的是一个template函数, 它接受了一个包含有博客标题和几个相关URL的对象. Sofa使用的template函数相当简单; 它只是用传入的值替换掉模版里的一些字符串. 在这个例子里, 模版字符串存储在变量templates.index.head里, 它是由在函数最开始由一个CouchApp宏导入的. template函数的第二个参数是将会插入到模版中的那些值; 在这个例子里是标题, feed地址, 新建日志地址, 首页地址以及一些assets地址. 在本章的后面部分, 我们会来讲解模版本身. 对于现在来说, 知道保存在变量templates.index.head的模版生成了最近日志页面的最上面部分就足够了. 它不随我们的最近日志视图的改变而改变.

我们已经生成的页面的最上面部分, 是时候把日志一篇一篇的显示出来了. 我们要做的第一件事是声明用于循环的变量:


						var row, key;
						while (row = getRow()) {
							var post = row.value;
							key = row.key;

变量row用于存储发送到函数的每一次JSON视图结果的记录. 变量key有着不同的作用. 因为我们不能提前知道哪个记录是我们要处理的最后一条记录, 所以我们把key存储在它自己的变量里, 以便于在处理完所有的记录后来生成下一行结果的链接.

				send(template(templates.index.row, {
						title : post.title,
						summary : post.summary,
						date : post.created_at,
						link : showPath('post', row.id)
					}));
				}

好了, 我们已经把row以及其key安全的存储在了变量里, 我们再一次使用模版引擎来生成页面. 这一次我们使用存储在templates.index.row里的模版, 传入的数据包括日志标题, 日志页面的URL链接, map视图生成的日志摘要, 以及日志的创建日期.

当所有包含在视图结果里的日志都列出来后, 我们已经差不多结束list函数和生成页面了. The last string does not need to be sent to the client using send(), but it can be returned from the HTML function. Aside from that minor detail, rendering the tail template should be familiar by now.

						return template(templates.index.tail, {
							assets : assetPath(),
							older : olderPath(key)
						});
					});

当tail被返回以后, 我们就完全了HTML的生成函数. 如果不需要提供博客的Atom feed, 我们已经做完了. 但是我们知道大多数读者会使用feed阅读器或者其他类型的同步软件来订阅我们的博客, 所以提供一个Atom feed很重要.

					provides("atom", function() {

Atom生成函数就和HTML生成函数一样定义, 调用provides函数, 传入参数为想要的输出格式. Atom函数的一般模式和HTML函数也相同: 输出feed的第一部分, 然后输出feed的主体内容, 最后结束feed.

						// we load the first row to find the most recent change date
						var row = getRow();

有一点对于Atom feed是不同的, 我们需要知道它最后更新的时间. 一般情况下, 这个时间是feed中第一个记录变更的时间, 所以我们在输出数据到客户端前(不同于HTTP头, HTTP头是在provide函数选择格式时设置的), 读取其第一条记录. 有了第一条记录后, 我们就可以使用其中的数据来设置Atom feed的最后更新时间.

						// generate the feed header
						var feedHeader = Atom.header({
							updated : (row ? new Date(row.value.created_at) : new Date()),
							title : blog.title,
							feed_id : makeAbsolute(req, indexPath),
							feed_link : makeAbsolute(req, feedPath),
						});

Atom.header函数定义在lib/atom.js里, 它在函数的最顶层由CouchApp导入了. 这个库使用了JavaScript的E4X扩展来生成feed XML.

						// send the header to the client
						send(feedHeader);

feed头生成以后, 使用我们熟悉的send()函数来发送它. 这样我们就设置好了头, 接下来将根据视图里的每条记录来生成Atom的主体内容. 我们会使用和HTML稍有不同的循环格式, 因为我们为了生成feed头的时间戳已经记取了第一行记录.

						// loop over all rows
						if (row) {
							do {

JavaScript的do/while循环和HTML函数里使用的while循环类似, 不同之处在于它保证循环至少会被执行一次, 因为它在每次循环之后才检查条件判断. 这意味着我们可以在调用getRow()读取下一条记录前, 输出已经读取的那一条记录. 

								// generate the entry for this row
								var feedEntry = Atom.entry({
									entry_id : makeAbsolute(req, '/' +
										encodeURIComponent(req.info.db_name) +
										'/' + encodeURIComponent(row.id)),
									title : row.value.title,
									content : row.value.html,
									updated : new Date(row.value.created_at),
									author : row.value.author,
									alternate : makeAbsolute(req, showPath('post', row.id))
								});
								// send the entry to client
								send(feedEntry);

生成主体内容同样使用的atom.js里的Atom库. Atom主体和HTML里的列表内容最大的不同在于, 对于HTML我们只输出内容的摘要, 而对于Atom内容我们则要输出全部的内容. 把row.value.html改成row.value.summary, 你就能把Atom feed变为只包含内容摘要的feed, 迫使订阅者通过点击真正的日志链接来阅读它.

							} while (row = getRow());
						}

正如前面所提到的, 这个循环格式把循环条件放在循环的最后, 所以从这里开始我们才会读取下一条记录.

						// close the loop after all rows are rendered
						return "</feed>";
					});
				};

当所有的记录都被循环完后, 我们返回XML的关闭标签作为最后一块数据.

#### 最终结果 ####

图1, "生成的首页页面" 展示了最终的结果

![生成的首页页面](lists/01.png)

这就是我们最后的日志列表. 不坏吧? 现在我们有了博客的首页, 知道了如何查询一个单一的文档以及视图, 以及如何给视图传递参数.
